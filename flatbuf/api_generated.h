// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_API_IROHA_H_
#define FLATBUFFERS_GENERATED_API_IROHA_H_
#include <iostream>
#include "flatbuffers/flatbuffers.h"

namespace iroha {

struct BaseObject;
struct BaseObjectT;

struct Asset;
struct AssetT;

struct Account;
struct AccountT;

struct Domain;
struct DomainT;

struct Peer;
struct PeerT;

struct Add;
struct AddT;

struct Transfer;
struct TransferT;

struct Update;
struct UpdateT;

struct Remove;
struct RemoveT;

struct Batch;
struct BatchT;

struct Unbatch;
struct UnbatchT;

struct Contract;
struct ContractT;

struct TxSignature;
struct TxSignatureT;

struct Transaction;
struct TransactionT;

struct Response;
struct ResponseT;

struct Request;
struct RequestT;

struct Query;
struct QueryT;

struct EventSignature;
struct EventSignatureT;

struct ConsensusEvent;
struct ConsensusEventT;

enum BaseObjectType {
  BaseObjectType_Text = 1,
  BaseObjectType_Integer = 2,
  BaseObjectType_Boolean = 3,
  BaseObjectType_Decimal = 4,
  BaseObjectType_None = 5,
  BaseObjectType_MIN = BaseObjectType_Text,
  BaseObjectType_MAX = BaseObjectType_None
};

inline const char **EnumNamesBaseObjectType() {
  static const char *names[] = {
    "Text",
    "Integer",
    "Boolean",
    "Decimal",
    "None",
    nullptr
  };
  return names;
}

inline const char *EnumNameBaseObjectType(BaseObjectType e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(BaseObjectType_Text);
  return EnumNamesBaseObjectType()[index];
}

enum Object {
  Object_NONE = 0,
  Object_Asset = 1,
  Object_Domain = 2,
  Object_Account = 3,
  Object_Peer = 4,
  Object_MIN = Object_NONE,
  Object_MAX = Object_Peer
};

inline const char **EnumNamesObject() {
  static const char *names[] = {
    "NONE",
    "Asset",
    "Domain",
    "Account",
    "Peer",
    nullptr
  };
  return names;
}

inline const char *EnumNameObject(Object e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesObject()[index];
}

template<typename T> struct ObjectTraits {
  static const Object enum_value = Object_NONE;
};

template<> struct ObjectTraits<Asset> {
  static const Object enum_value = Object_Asset;
};

template<> struct ObjectTraits<Domain> {
  static const Object enum_value = Object_Domain;
};

template<> struct ObjectTraits<Account> {
  static const Object enum_value = Object_Account;
};

template<> struct ObjectTraits<Peer> {
  static const Object enum_value = Object_Peer;
};

struct ObjectUnion {
  Object type;
  flatbuffers::NativeTable *table;

  ObjectUnion() : type(Object_NONE), table(nullptr) {}

  template <typename T>
  ObjectUnion(T&& value) : type(ObjectTraits<typename T::TableType>::enum_value) {
    if (type != Object_NONE) {
      table = new T(std::forward<T>(value));
    }
  }

  ObjectUnion(const ObjectUnion &);
  ObjectUnion(ObjectUnion&&) = default;
  ObjectUnion &operator=(ObjectUnion&&) = default;
  ObjectUnion &operator=(const ObjectUnion &);
  ~ObjectUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& value) {
    Reset();
    type = ObjectTraits<typename T::TableType>::enum_value;
    if (type != Object_NONE) {
      table = new T(std::forward<T>(value));
    }
  }

  static flatbuffers::NativeTable *UnPack(const void *obj, Object type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  AssetT *AsAsset() {
    return type == Object_Asset ?
      reinterpret_cast<AssetT *>(table) : nullptr;
  }
  DomainT *AsDomain() {
    return type == Object_Domain ?
      reinterpret_cast<DomainT *>(table) : nullptr;
  }
  AccountT *AsAccount() {
    return type == Object_Account ?
      reinterpret_cast<AccountT *>(table) : nullptr;
  }
  PeerT *AsPeer() {
    return type == Object_Peer ?
      reinterpret_cast<PeerT *>(table) : nullptr;
  }
};

bool VerifyObject(flatbuffers::Verifier &verifier, const void *obj, Object type);
bool VerifyObjectVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum Command {
  Command_NONE = 0,
  Command_Add = 1,
  Command_Transfer = 2,
  Command_Update = 3,
  Command_Remove = 4,
  Command_Batch = 5,
  Command_Unbatch = 6,
  Command_Contract = 7,
  Command_MIN = Command_NONE,
  Command_MAX = Command_Contract
};

inline const char **EnumNamesCommand() {
  static const char *names[] = {
    "NONE",
    "Add",
    "Transfer",
    "Update",
    "Remove",
    "Batch",
    "Unbatch",
    "Contract",
    nullptr
  };
  return names;
}

inline const char *EnumNameCommand(Command e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCommand()[index];
}

template<typename T> struct CommandTraits {
  static const Command enum_value = Command_NONE;
};

template<> struct CommandTraits<Add> {
  static const Command enum_value = Command_Add;
};

template<> struct CommandTraits<Transfer> {
  static const Command enum_value = Command_Transfer;
};

template<> struct CommandTraits<Update> {
  static const Command enum_value = Command_Update;
};

template<> struct CommandTraits<Remove> {
  static const Command enum_value = Command_Remove;
};

template<> struct CommandTraits<Batch> {
  static const Command enum_value = Command_Batch;
};

template<> struct CommandTraits<Unbatch> {
  static const Command enum_value = Command_Unbatch;
};

template<> struct CommandTraits<Contract> {
  static const Command enum_value = Command_Contract;
};

struct CommandUnion {
  Command type;
  flatbuffers::NativeTable *table;

  CommandUnion() : type(Command_NONE), table(nullptr) {}

  template <typename T>
  CommandUnion(T&& value) : type(CommandTraits<typename T::TableType>::enum_value) {
    if (type != Command_NONE) {
      table = new T(std::forward<T>(value));
    }
  }

  CommandUnion(const CommandUnion &);
  CommandUnion(CommandUnion&&) = default;
  CommandUnion &operator=(CommandUnion&&) = default;
  CommandUnion &operator=(const CommandUnion &);
  ~CommandUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& value) {
    Reset();
    type = CommandTraits<typename T::TableType>::enum_value;
    if (type != Command_NONE) {
      table = new T(std::forward<T>(value));
    }
  }

  static flatbuffers::NativeTable *UnPack(const void *obj, Command type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  AddT *AsAdd() {
    return type == Command_Add ?
      reinterpret_cast<AddT *>(table) : nullptr;
  }
  TransferT *AsTransfer() {
    return type == Command_Transfer ?
      reinterpret_cast<TransferT *>(table) : nullptr;
  }
  UpdateT *AsUpdate() {
    return type == Command_Update ?
      reinterpret_cast<UpdateT *>(table) : nullptr;
  }
  RemoveT *AsRemove() {
    return type == Command_Remove ?
      reinterpret_cast<RemoveT *>(table) : nullptr;
  }
  BatchT *AsBatch() {
    return type == Command_Batch ?
      reinterpret_cast<BatchT *>(table) : nullptr;
  }
  UnbatchT *AsUnbatch() {
    return type == Command_Unbatch ?
      reinterpret_cast<UnbatchT *>(table) : nullptr;
  }
  ContractT *AsContract() {
    return type == Command_Contract ?
      reinterpret_cast<ContractT *>(table) : nullptr;
  }
};

bool VerifyCommand(flatbuffers::Verifier &verifier, const void *obj, Command type);
bool VerifyCommandVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum QueryType {
  QueryType_TransactionHistory = 0,
  QueryType_HashTree = 1,
  QueryType_ObjectInformation = 2,
  QueryType_MIN = QueryType_TransactionHistory,
  QueryType_MAX = QueryType_ObjectInformation
};

inline const char **EnumNamesQueryType() {
  static const char *names[] = {
    "TransactionHistory",
    "HashTree",
    "ObjectInformation",
    nullptr
  };
  return names;
}

inline const char *EnumNameQueryType(QueryType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesQueryType()[index];
}

enum State {
  State_Undetermined = 0,
  State_Commited = 1,
  State_Rejected = 2,
  State_MIN = State_Undetermined,
  State_MAX = State_Rejected
};

inline const char **EnumNamesState() {
  static const char *names[] = {
    "Undetermined",
    "Commited",
    "Rejected",
    nullptr
  };
  return names;
}

inline const char *EnumNameState(State e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesState()[index];
}

struct BaseObjectT : public flatbuffers::NativeTable {
  typedef BaseObject TableType;
  std::string text;
  int32_t integer;
  bool boolean;
  float decimal;
  BaseObjectType type;
  std::string name;
  BaseObjectT()
      : text(""),
        integer(0),
        boolean(false),
        decimal(0.0f),
        type(BaseObjectType_None),
        name("") {
  }
};

struct BaseObject FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BaseObjectT NativeTableType;
  enum {
    VT_TEXT = 4,
    VT_INTEGER = 6,
    VT_BOOLEAN = 8,
    VT_DECIMAL = 10,
    VT_TYPE = 12,
    VT_NAME = 14
  };
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  int32_t integer() const {
    return GetField<int32_t>(VT_INTEGER, 0);
  }
  bool boolean() const {
    return GetField<uint8_t>(VT_BOOLEAN, 0) != 0;
  }
  float decimal() const {
    return GetField<float>(VT_DECIMAL, 0.0f);
  }
  BaseObjectType type() const {
    return static_cast<BaseObjectType>(GetField<int8_t>(VT_TYPE, 5));
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TEXT) &&
           verifier.Verify(text()) &&
           VerifyField<int32_t>(verifier, VT_INTEGER) &&
           VerifyField<uint8_t>(verifier, VT_BOOLEAN) &&
           VerifyField<float>(verifier, VT_DECIMAL) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           verifier.EndTable();
  }
  BaseObjectT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BaseObjectT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BaseObject> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BaseObjectT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BaseObjectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(BaseObject::VT_TEXT, text);
  }
  void add_integer(int32_t integer) {
    fbb_.AddElement<int32_t>(BaseObject::VT_INTEGER, integer, 0);
  }
  void add_boolean(bool boolean) {
    fbb_.AddElement<uint8_t>(BaseObject::VT_BOOLEAN, static_cast<uint8_t>(boolean), 0);
  }
  void add_decimal(float decimal) {
    fbb_.AddElement<float>(BaseObject::VT_DECIMAL, decimal, 0.0f);
  }
  void add_type(BaseObjectType type) {
    fbb_.AddElement<int8_t>(BaseObject::VT_TYPE, static_cast<int8_t>(type), 5);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(BaseObject::VT_NAME, name);
  }
  BaseObjectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BaseObjectBuilder &operator=(const BaseObjectBuilder &);
  flatbuffers::Offset<BaseObject> Finish() {
    const auto end = fbb_.EndTable(start_, 6);
    auto o = flatbuffers::Offset<BaseObject>(end);
    fbb_.Required(o, BaseObject::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<BaseObject> CreateBaseObject(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> text = 0,
    int32_t integer = 0,
    bool boolean = false,
    float decimal = 0.0f,
    BaseObjectType type = BaseObjectType_None,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  BaseObjectBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_decimal(decimal);
  builder_.add_integer(integer);
  builder_.add_text(text);
  builder_.add_type(type);
  builder_.add_boolean(boolean);
  return builder_.Finish();
}

inline flatbuffers::Offset<BaseObject> CreateBaseObjectDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr,
    int32_t integer = 0,
    bool boolean = false,
    float decimal = 0.0f,
    BaseObjectType type = BaseObjectType_None,
    const char *name = nullptr) {
  return CreateBaseObject(
      _fbb,
      text ? _fbb.CreateString(text) : 0,
      integer,
      boolean,
      decimal,
      type,
      name ? _fbb.CreateString(name) : 0);
}

flatbuffers::Offset<BaseObject> CreateBaseObject(flatbuffers::FlatBufferBuilder &_fbb, const BaseObjectT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AssetT : public flatbuffers::NativeTable {
  typedef Asset TableType;
  std::string name;
  std::string domain;
  bool isSingleAsset;
  std::vector<std::unique_ptr<BaseObjectT>> objects;
  std::string smartContractName;
  AssetT()
      : isSingleAsset(false) {
  }
};

struct Asset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AssetT NativeTableType;
  enum {
    VT_NAME = 4,
    VT_DOMAIN = 6,
    VT_ISSINGLEASSET = 8,
    VT_OBJECTS = 10,
    VT_SMARTCONTRACTNAME = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *domain() const {
    return GetPointer<const flatbuffers::String *>(VT_DOMAIN);
  }
  bool isSingleAsset() const {
    return GetField<uint8_t>(VT_ISSINGLEASSET, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<BaseObject>> *objects() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BaseObject>> *>(VT_OBJECTS);
  }
  const flatbuffers::String *smartContractName() const {
    return GetPointer<const flatbuffers::String *>(VT_SMARTCONTRACTNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_DOMAIN) &&
           verifier.Verify(domain()) &&
           VerifyField<uint8_t>(verifier, VT_ISSINGLEASSET) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_OBJECTS) &&
           verifier.Verify(objects()) &&
           verifier.VerifyVectorOfTables(objects()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SMARTCONTRACTNAME) &&
           verifier.Verify(smartContractName()) &&
           verifier.EndTable();
  }
  AssetT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AssetT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Asset> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssetT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AssetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Asset::VT_NAME, name);
  }
  void add_domain(flatbuffers::Offset<flatbuffers::String> domain) {
    fbb_.AddOffset(Asset::VT_DOMAIN, domain);
  }
  void add_isSingleAsset(bool isSingleAsset) {
    fbb_.AddElement<uint8_t>(Asset::VT_ISSINGLEASSET, static_cast<uint8_t>(isSingleAsset), 0);
  }
  void add_objects(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BaseObject>>> objects) {
    fbb_.AddOffset(Asset::VT_OBJECTS, objects);
  }
  void add_smartContractName(flatbuffers::Offset<flatbuffers::String> smartContractName) {
    fbb_.AddOffset(Asset::VT_SMARTCONTRACTNAME, smartContractName);
  }
  AssetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssetBuilder &operator=(const AssetBuilder &);
  flatbuffers::Offset<Asset> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<Asset>(end);
    fbb_.Required(o, Asset::VT_NAME);
    fbb_.Required(o, Asset::VT_DOMAIN);
    return o;
  }
};

inline flatbuffers::Offset<Asset> CreateAsset(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> domain = 0,
    bool isSingleAsset = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BaseObject>>> objects = 0,
    flatbuffers::Offset<flatbuffers::String> smartContractName = 0) {
  std::cout << "\033[1m\033[92m ---- CreateAsset -------- \033[0m\n";
  AssetBuilder builder_(_fbb);
  builder_.add_smartContractName(smartContractName);
  builder_.add_objects(objects);
  builder_.add_domain(domain);
  builder_.add_name(name);
  builder_.add_isSingleAsset(isSingleAsset);
  return builder_.Finish();
}

inline flatbuffers::Offset<Asset> CreateAssetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *domain = nullptr,
    bool isSingleAsset = false,
    const std::vector<flatbuffers::Offset<BaseObject>> *objects = nullptr,
    const char *smartContractName = nullptr) {
  std::cout << "\033[1m\033[92m ---- CreateAssetDirect -------- \033[0m\n";
  if(objects == nullptr )
    std::cout << "\033[1m\033[92m ---- yurushite -------- \033[0m\n";
  return CreateAsset(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      domain ? _fbb.CreateString(domain) : 0,
      isSingleAsset,
      objects ? _fbb.CreateVector<flatbuffers::Offset<BaseObject>>(*objects) : 0,
      smartContractName ? _fbb.CreateString(smartContractName) : 0);
}

flatbuffers::Offset<Asset> CreateAsset(flatbuffers::FlatBufferBuilder &_fbb, const AssetT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AccountT : public flatbuffers::NativeTable {
  typedef Account TableType;
  std::string publicKey;
  std::vector<std::unique_ptr<AssetT>> assets;
  AccountT() {
  }
};

struct Account FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AccountT NativeTableType;
  enum {
    VT_PUBLICKEY = 4,
    VT_ASSETS = 6
  };
  const flatbuffers::String *publicKey() const {
    return GetPointer<const flatbuffers::String *>(VT_PUBLICKEY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Asset>> *assets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Asset>> *>(VT_ASSETS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_PUBLICKEY) &&
           verifier.Verify(publicKey()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ASSETS) &&
           verifier.Verify(assets()) &&
           verifier.VerifyVectorOfTables(assets()) &&
           verifier.EndTable();
  }
  AccountT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AccountT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Account> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AccountT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AccountBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_publicKey(flatbuffers::Offset<flatbuffers::String> publicKey) {
    fbb_.AddOffset(Account::VT_PUBLICKEY, publicKey);
  }
  void add_assets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Asset>>> assets) {
    fbb_.AddOffset(Account::VT_ASSETS, assets);
  }
  AccountBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AccountBuilder &operator=(const AccountBuilder &);
  flatbuffers::Offset<Account> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Account>(end);
    fbb_.Required(o, Account::VT_PUBLICKEY);
    return o;
  }
};

inline flatbuffers::Offset<Account> CreateAccount(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> publicKey = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Asset>>> assets = 0) {
  AccountBuilder builder_(_fbb);
  builder_.add_assets(assets);
  builder_.add_publicKey(publicKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<Account> CreateAccountDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *publicKey = nullptr,
    const std::vector<flatbuffers::Offset<Asset>> *assets = nullptr) {
  return CreateAccount(
      _fbb,
      publicKey ? _fbb.CreateString(publicKey) : 0,
      assets ? _fbb.CreateVector<flatbuffers::Offset<Asset>>(*assets) : 0);
}

flatbuffers::Offset<Account> CreateAccount(flatbuffers::FlatBufferBuilder &_fbb, const AccountT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DomainT : public flatbuffers::NativeTable {
  typedef Domain TableType;
  std::string ownerPublicKey;
  std::string name;
  DomainT() {
  }
};

struct Domain FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DomainT NativeTableType;
  enum {
    VT_OWNERPUBLICKEY = 4,
    VT_NAME = 6
  };
  const flatbuffers::String *ownerPublicKey() const {
    return GetPointer<const flatbuffers::String *>(VT_OWNERPUBLICKEY);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_OWNERPUBLICKEY) &&
           verifier.Verify(ownerPublicKey()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           verifier.EndTable();
  }
  DomainT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DomainT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Domain> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DomainT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DomainBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ownerPublicKey(flatbuffers::Offset<flatbuffers::String> ownerPublicKey) {
    fbb_.AddOffset(Domain::VT_OWNERPUBLICKEY, ownerPublicKey);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Domain::VT_NAME, name);
  }
  DomainBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DomainBuilder &operator=(const DomainBuilder &);
  flatbuffers::Offset<Domain> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Domain>(end);
    return o;
  }
};

inline flatbuffers::Offset<Domain> CreateDomain(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ownerPublicKey = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  DomainBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_ownerPublicKey(ownerPublicKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<Domain> CreateDomainDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ownerPublicKey = nullptr,
    const char *name = nullptr) {
  return CreateDomain(
      _fbb,
      ownerPublicKey ? _fbb.CreateString(ownerPublicKey) : 0,
      name ? _fbb.CreateString(name) : 0);
}

flatbuffers::Offset<Domain> CreateDomain(flatbuffers::FlatBufferBuilder &_fbb, const DomainT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PeerT : public flatbuffers::NativeTable {
  typedef Peer TableType;
  std::string publicKey;
  std::string address;
  PeerT() {
  }
};

struct Peer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PeerT NativeTableType;
  enum {
    VT_PUBLICKEY = 4,
    VT_ADDRESS = 6
  };
  const flatbuffers::String *publicKey() const {
    return GetPointer<const flatbuffers::String *>(VT_PUBLICKEY);
  }
  const flatbuffers::String *address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PUBLICKEY) &&
           verifier.Verify(publicKey()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           verifier.EndTable();
  }
  PeerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PeerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Peer> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PeerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PeerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_publicKey(flatbuffers::Offset<flatbuffers::String> publicKey) {
    fbb_.AddOffset(Peer::VT_PUBLICKEY, publicKey);
  }
  void add_address(flatbuffers::Offset<flatbuffers::String> address) {
    fbb_.AddOffset(Peer::VT_ADDRESS, address);
  }
  PeerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PeerBuilder &operator=(const PeerBuilder &);
  flatbuffers::Offset<Peer> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Peer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Peer> CreatePeer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> publicKey = 0,
    flatbuffers::Offset<flatbuffers::String> address = 0) {
  PeerBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_publicKey(publicKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<Peer> CreatePeerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *publicKey = nullptr,
    const char *address = nullptr) {
  return CreatePeer(
      _fbb,
      publicKey ? _fbb.CreateString(publicKey) : 0,
      address ? _fbb.CreateString(address) : 0);
}

flatbuffers::Offset<Peer> CreatePeer(flatbuffers::FlatBufferBuilder &_fbb, const PeerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AddT : public flatbuffers::NativeTable {
  typedef Add TableType;
  ObjectUnion object;
  AddT() {
  }
};

struct Add FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AddT NativeTableType;
  enum {
    VT_OBJECT_TYPE = 4,
    VT_OBJECT = 6
  };
  Object object_type() const {
    return static_cast<Object>(GetField<uint8_t>(VT_OBJECT_TYPE, 0));
  }
  const void *object() const {
    return GetPointer<const void *>(VT_OBJECT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_OBJECT) &&
           VerifyObject(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
  AddT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AddT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Add> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AddBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_type(Object object_type) {
    fbb_.AddElement<uint8_t>(Add::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0);
  }
  void add_object(flatbuffers::Offset<void> object) {
    fbb_.AddOffset(Add::VT_OBJECT, object);
  }
  AddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddBuilder &operator=(const AddBuilder &);
  flatbuffers::Offset<Add> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Add>(end);
    fbb_.Required(o, Add::VT_OBJECT);
    return o;
  }
};

inline flatbuffers::Offset<Add> CreateAdd(
    flatbuffers::FlatBufferBuilder &_fbb,
    Object object_type = Object_NONE,
    flatbuffers::Offset<void> object = 0) {
  AddBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

flatbuffers::Offset<Add> CreateAdd(flatbuffers::FlatBufferBuilder &_fbb, const AddT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransferT : public flatbuffers::NativeTable {
  typedef Transfer TableType;
  std::string receiver;
  ObjectUnion object;
  TransferT() {
  }
};

struct Transfer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TransferT NativeTableType;
  enum {
    VT_RECEIVER = 4,
    VT_OBJECT_TYPE = 6,
    VT_OBJECT = 8
  };
  const flatbuffers::String *receiver() const {
    return GetPointer<const flatbuffers::String *>(VT_RECEIVER);
  }
  Object object_type() const {
    return static_cast<Object>(GetField<uint8_t>(VT_OBJECT_TYPE, 0));
  }
  const void *object() const {
    return GetPointer<const void *>(VT_OBJECT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_RECEIVER) &&
           verifier.Verify(receiver()) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_OBJECT) &&
           VerifyObject(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
  TransferT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransferT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Transfer> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransferT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransferBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_receiver(flatbuffers::Offset<flatbuffers::String> receiver) {
    fbb_.AddOffset(Transfer::VT_RECEIVER, receiver);
  }
  void add_object_type(Object object_type) {
    fbb_.AddElement<uint8_t>(Transfer::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0);
  }
  void add_object(flatbuffers::Offset<void> object) {
    fbb_.AddOffset(Transfer::VT_OBJECT, object);
  }
  TransferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransferBuilder &operator=(const TransferBuilder &);
  flatbuffers::Offset<Transfer> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Transfer>(end);
    fbb_.Required(o, Transfer::VT_RECEIVER);
    fbb_.Required(o, Transfer::VT_OBJECT);
    return o;
  }
};

inline flatbuffers::Offset<Transfer> CreateTransfer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> receiver = 0,
    Object object_type = Object_NONE,
    flatbuffers::Offset<void> object = 0) {
  TransferBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_receiver(receiver);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Transfer> CreateTransferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *receiver = nullptr,
    Object object_type = Object_NONE,
    flatbuffers::Offset<void> object = 0) {
  return CreateTransfer(
      _fbb,
      receiver ? _fbb.CreateString(receiver) : 0,
      object_type,
      object);
}

flatbuffers::Offset<Transfer> CreateTransfer(flatbuffers::FlatBufferBuilder &_fbb, const TransferT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UpdateT : public flatbuffers::NativeTable {
  typedef Update TableType;
  ObjectUnion object;
  UpdateT() {
  }
};

struct Update FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UpdateT NativeTableType;
  enum {
    VT_OBJECT_TYPE = 4,
    VT_OBJECT = 6
  };
  Object object_type() const {
    return static_cast<Object>(GetField<uint8_t>(VT_OBJECT_TYPE, 0));
  }
  const void *object() const {
    return GetPointer<const void *>(VT_OBJECT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_OBJECT) &&
           VerifyObject(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
  UpdateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UpdateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Update> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UpdateT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UpdateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_type(Object object_type) {
    fbb_.AddElement<uint8_t>(Update::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0);
  }
  void add_object(flatbuffers::Offset<void> object) {
    fbb_.AddOffset(Update::VT_OBJECT, object);
  }
  UpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpdateBuilder &operator=(const UpdateBuilder &);
  flatbuffers::Offset<Update> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Update>(end);
    fbb_.Required(o, Update::VT_OBJECT);
    return o;
  }
};

inline flatbuffers::Offset<Update> CreateUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    Object object_type = Object_NONE,
    flatbuffers::Offset<void> object = 0) {
  UpdateBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

flatbuffers::Offset<Update> CreateUpdate(flatbuffers::FlatBufferBuilder &_fbb, const UpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RemoveT : public flatbuffers::NativeTable {
  typedef Remove TableType;
  ObjectUnion object;
  RemoveT() {
  }
};

struct Remove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RemoveT NativeTableType;
  enum {
    VT_OBJECT_TYPE = 4,
    VT_OBJECT = 6
  };
  Object object_type() const {
    return static_cast<Object>(GetField<uint8_t>(VT_OBJECT_TYPE, 0));
  }
  const void *object() const {
    return GetPointer<const void *>(VT_OBJECT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_OBJECT) &&
           VerifyObject(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
  RemoveT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RemoveT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Remove> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RemoveT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RemoveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_type(Object object_type) {
    fbb_.AddElement<uint8_t>(Remove::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0);
  }
  void add_object(flatbuffers::Offset<void> object) {
    fbb_.AddOffset(Remove::VT_OBJECT, object);
  }
  RemoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RemoveBuilder &operator=(const RemoveBuilder &);
  flatbuffers::Offset<Remove> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Remove>(end);
    fbb_.Required(o, Remove::VT_OBJECT);
    return o;
  }
};

inline flatbuffers::Offset<Remove> CreateRemove(
    flatbuffers::FlatBufferBuilder &_fbb,
    Object object_type = Object_NONE,
    flatbuffers::Offset<void> object = 0) {
  RemoveBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

flatbuffers::Offset<Remove> CreateRemove(flatbuffers::FlatBufferBuilder &_fbb, const RemoveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BatchT : public flatbuffers::NativeTable {
  typedef Batch TableType;
  std::string alias;
  std::vector<std::string> commands;
  BatchT() {
  }
};

struct Batch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchT NativeTableType;
  enum {
    VT_ALIAS = 4,
    VT_COMMANDS = 6
  };
  const flatbuffers::String *alias() const {
    return GetPointer<const flatbuffers::String *>(VT_ALIAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *commands() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_COMMANDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ALIAS) &&
           verifier.Verify(alias()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_COMMANDS) &&
           verifier.Verify(commands()) &&
           verifier.VerifyVectorOfStrings(commands()) &&
           verifier.EndTable();
  }
  BatchT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BatchT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Batch> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BatchBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alias(flatbuffers::Offset<flatbuffers::String> alias) {
    fbb_.AddOffset(Batch::VT_ALIAS, alias);
  }
  void add_commands(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> commands) {
    fbb_.AddOffset(Batch::VT_COMMANDS, commands);
  }
  BatchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BatchBuilder &operator=(const BatchBuilder &);
  flatbuffers::Offset<Batch> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Batch>(end);
    fbb_.Required(o, Batch::VT_ALIAS);
    return o;
  }
};

inline flatbuffers::Offset<Batch> CreateBatch(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> alias = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> commands = 0) {
  BatchBuilder builder_(_fbb);
  builder_.add_commands(commands);
  builder_.add_alias(alias);
  return builder_.Finish();
}

inline flatbuffers::Offset<Batch> CreateBatchDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *alias = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *commands = nullptr) {
  return CreateBatch(
      _fbb,
      alias ? _fbb.CreateString(alias) : 0,
      commands ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*commands) : 0);
}

flatbuffers::Offset<Batch> CreateBatch(flatbuffers::FlatBufferBuilder &_fbb, const BatchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnbatchT : public flatbuffers::NativeTable {
  typedef Unbatch TableType;
  std::string alias;
  UnbatchT() {
  }
};

struct Unbatch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnbatchT NativeTableType;
  enum {
    VT_ALIAS = 4
  };
  const flatbuffers::String *alias() const {
    return GetPointer<const flatbuffers::String *>(VT_ALIAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ALIAS) &&
           verifier.Verify(alias()) &&
           verifier.EndTable();
  }
  UnbatchT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnbatchT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Unbatch> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnbatchT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnbatchBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alias(flatbuffers::Offset<flatbuffers::String> alias) {
    fbb_.AddOffset(Unbatch::VT_ALIAS, alias);
  }
  UnbatchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnbatchBuilder &operator=(const UnbatchBuilder &);
  flatbuffers::Offset<Unbatch> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Unbatch>(end);
    fbb_.Required(o, Unbatch::VT_ALIAS);
    return o;
  }
};

inline flatbuffers::Offset<Unbatch> CreateUnbatch(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> alias = 0) {
  UnbatchBuilder builder_(_fbb);
  builder_.add_alias(alias);
  return builder_.Finish();
}

inline flatbuffers::Offset<Unbatch> CreateUnbatchDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *alias = nullptr) {
  return CreateUnbatch(
      _fbb,
      alias ? _fbb.CreateString(alias) : 0);
}

flatbuffers::Offset<Unbatch> CreateUnbatch(flatbuffers::FlatBufferBuilder &_fbb, const UnbatchT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ContractT : public flatbuffers::NativeTable {
  typedef Contract TableType;
  ObjectUnion object;
  std::string command;
  std::string contractName;
  ContractT() {
  }
};

struct Contract FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ContractT NativeTableType;
  enum {
    VT_OBJECT_TYPE = 4,
    VT_OBJECT = 6,
    VT_COMMAND = 8,
    VT_CONTRACTNAME = 10
  };
  Object object_type() const {
    return static_cast<Object>(GetField<uint8_t>(VT_OBJECT_TYPE, 0));
  }
  const void *object() const {
    return GetPointer<const void *>(VT_OBJECT);
  }
  const flatbuffers::String *command() const {
    return GetPointer<const flatbuffers::String *>(VT_COMMAND);
  }
  const flatbuffers::String *contractName() const {
    return GetPointer<const flatbuffers::String *>(VT_CONTRACTNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_OBJECT) &&
           VerifyObject(verifier, object(), object_type()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_COMMAND) &&
           verifier.Verify(command()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_CONTRACTNAME) &&
           verifier.Verify(contractName()) &&
           verifier.EndTable();
  }
  ContractT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ContractT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Contract> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ContractT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ContractBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_type(Object object_type) {
    fbb_.AddElement<uint8_t>(Contract::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0);
  }
  void add_object(flatbuffers::Offset<void> object) {
    fbb_.AddOffset(Contract::VT_OBJECT, object);
  }
  void add_command(flatbuffers::Offset<flatbuffers::String> command) {
    fbb_.AddOffset(Contract::VT_COMMAND, command);
  }
  void add_contractName(flatbuffers::Offset<flatbuffers::String> contractName) {
    fbb_.AddOffset(Contract::VT_CONTRACTNAME, contractName);
  }
  ContractBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ContractBuilder &operator=(const ContractBuilder &);
  flatbuffers::Offset<Contract> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<Contract>(end);
    fbb_.Required(o, Contract::VT_OBJECT);
    fbb_.Required(o, Contract::VT_CONTRACTNAME);
    return o;
  }
};

inline flatbuffers::Offset<Contract> CreateContract(
    flatbuffers::FlatBufferBuilder &_fbb,
    Object object_type = Object_NONE,
    flatbuffers::Offset<void> object = 0,
    flatbuffers::Offset<flatbuffers::String> command = 0,
    flatbuffers::Offset<flatbuffers::String> contractName = 0) {
  ContractBuilder builder_(_fbb);
  builder_.add_contractName(contractName);
  builder_.add_command(command);
  builder_.add_object(object);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Contract> CreateContractDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Object object_type = Object_NONE,
    flatbuffers::Offset<void> object = 0,
    const char *command = nullptr,
    const char *contractName = nullptr) {
  return CreateContract(
      _fbb,
      object_type,
      object,
      command ? _fbb.CreateString(command) : 0,
      contractName ? _fbb.CreateString(contractName) : 0);
}

flatbuffers::Offset<Contract> CreateContract(flatbuffers::FlatBufferBuilder &_fbb, const ContractT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TxSignatureT : public flatbuffers::NativeTable {
  typedef TxSignature TableType;
  std::string publicKey;
  std::string signature;
  TxSignatureT() {
  }
};

struct TxSignature FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TxSignatureT NativeTableType;
  enum {
    VT_PUBLICKEY = 4,
    VT_SIGNATURE = 6
  };
  const flatbuffers::String *publicKey() const {
    return GetPointer<const flatbuffers::String *>(VT_PUBLICKEY);
  }
  const flatbuffers::String *signature() const {
    return GetPointer<const flatbuffers::String *>(VT_SIGNATURE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_PUBLICKEY) &&
           verifier.Verify(publicKey()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_SIGNATURE) &&
           verifier.Verify(signature()) &&
           verifier.EndTable();
  }
  TxSignatureT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TxSignatureT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TxSignature> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TxSignatureT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TxSignatureBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_publicKey(flatbuffers::Offset<flatbuffers::String> publicKey) {
    fbb_.AddOffset(TxSignature::VT_PUBLICKEY, publicKey);
  }
  void add_signature(flatbuffers::Offset<flatbuffers::String> signature) {
    fbb_.AddOffset(TxSignature::VT_SIGNATURE, signature);
  }
  TxSignatureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TxSignatureBuilder &operator=(const TxSignatureBuilder &);
  flatbuffers::Offset<TxSignature> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<TxSignature>(end);
    fbb_.Required(o, TxSignature::VT_PUBLICKEY);
    fbb_.Required(o, TxSignature::VT_SIGNATURE);
    return o;
  }
};

inline flatbuffers::Offset<TxSignature> CreateTxSignature(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> publicKey = 0,
    flatbuffers::Offset<flatbuffers::String> signature = 0) {
  TxSignatureBuilder builder_(_fbb);
  builder_.add_signature(signature);
  builder_.add_publicKey(publicKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<TxSignature> CreateTxSignatureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *publicKey = nullptr,
    const char *signature = nullptr) {
  return CreateTxSignature(
      _fbb,
      publicKey ? _fbb.CreateString(publicKey) : 0,
      signature ? _fbb.CreateString(signature) : 0);
}

flatbuffers::Offset<TxSignature> CreateTxSignature(flatbuffers::FlatBufferBuilder &_fbb, const TxSignatureT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TransactionT : public flatbuffers::NativeTable {
  typedef Transaction TableType;
  std::string sender;
  CommandUnion command;
  std::vector<std::unique_ptr<TxSignatureT>> txSignatures;
  std::string hash;
  TransactionT() {
  }
};

struct Transaction FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TransactionT NativeTableType;
  enum {
    VT_SENDER = 4,
    VT_COMMAND_TYPE = 6,
    VT_COMMAND = 8,
    VT_TXSIGNATURES = 10,
    VT_HASH = 12
  };
  const flatbuffers::String *sender() const {
    return GetPointer<const flatbuffers::String *>(VT_SENDER);
  }
  Command command_type() const {
    return static_cast<Command>(GetField<uint8_t>(VT_COMMAND_TYPE, 0));
  }
  const void *command() const {
    return GetPointer<const void *>(VT_COMMAND);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TxSignature>> *txSignatures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TxSignature>> *>(VT_TXSIGNATURES);
  }
  const flatbuffers::String *hash() const {
    return GetPointer<const flatbuffers::String *>(VT_HASH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_SENDER) &&
           verifier.Verify(sender()) &&
           VerifyField<uint8_t>(verifier, VT_COMMAND_TYPE) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_COMMAND) &&
           VerifyCommand(verifier, command(), command_type()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_TXSIGNATURES) &&
           verifier.Verify(txSignatures()) &&
           verifier.VerifyVectorOfTables(txSignatures()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_HASH) &&
           verifier.Verify(hash()) &&
           verifier.EndTable();
  }
  TransactionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TransactionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Transaction> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransactionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TransactionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sender(flatbuffers::Offset<flatbuffers::String> sender) {
    fbb_.AddOffset(Transaction::VT_SENDER, sender);
  }
  void add_command_type(Command command_type) {
    fbb_.AddElement<uint8_t>(Transaction::VT_COMMAND_TYPE, static_cast<uint8_t>(command_type), 0);
  }
  void add_command(flatbuffers::Offset<void> command) {
    fbb_.AddOffset(Transaction::VT_COMMAND, command);
  }
  void add_txSignatures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TxSignature>>> txSignatures) {
    fbb_.AddOffset(Transaction::VT_TXSIGNATURES, txSignatures);
  }
  void add_hash(flatbuffers::Offset<flatbuffers::String> hash) {
    fbb_.AddOffset(Transaction::VT_HASH, hash);
  }
  TransactionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransactionBuilder &operator=(const TransactionBuilder &);
  flatbuffers::Offset<Transaction> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<Transaction>(end);
    fbb_.Required(o, Transaction::VT_SENDER);
    fbb_.Required(o, Transaction::VT_COMMAND);
    fbb_.Required(o, Transaction::VT_TXSIGNATURES);
    fbb_.Required(o, Transaction::VT_HASH);
    return o;
  }
};

inline flatbuffers::Offset<Transaction> CreateTransaction(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> sender = 0,
    Command command_type = Command_NONE,
    flatbuffers::Offset<void> command = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TxSignature>>> txSignatures = 0,
    flatbuffers::Offset<flatbuffers::String> hash = 0) {
  TransactionBuilder builder_(_fbb);
  builder_.add_hash(hash);
  builder_.add_txSignatures(txSignatures);
  builder_.add_command(command);
  builder_.add_sender(sender);
  builder_.add_command_type(command_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Transaction> CreateTransactionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *sender = nullptr,
    Command command_type = Command_NONE,
    flatbuffers::Offset<void> command = 0,
    const std::vector<flatbuffers::Offset<TxSignature>> *txSignatures = nullptr,
    const char *hash = nullptr) {
  return CreateTransaction(
      _fbb,
      sender ? _fbb.CreateString(sender) : 0,
      command_type,
      command,
      txSignatures ? _fbb.CreateVector<flatbuffers::Offset<TxSignature>>(*txSignatures) : 0,
      hash ? _fbb.CreateString(hash) : 0);
}

flatbuffers::Offset<Transaction> CreateTransaction(flatbuffers::FlatBufferBuilder &_fbb, const TransactionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResponseT : public flatbuffers::NativeTable {
  typedef Response TableType;
  int32_t status;
  std::string message;
  std::vector<std::unique_ptr<TransactionT>> transaction;
  ObjectUnion object;
  ResponseT()
      : status(0) {
  }
};

struct Response FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResponseT NativeTableType;
  enum {
    VT_STATUS = 4,
    VT_MESSAGE = 6,
    VT_TRANSACTION = 8,
    VT_OBJECT_TYPE = 10,
    VT_OBJECT = 12
  };
  int32_t status() const {
    return GetField<int32_t>(VT_STATUS, 0);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Transaction>> *transaction() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Transaction>> *>(VT_TRANSACTION);
  }
  Object object_type() const {
    return static_cast<Object>(GetField<uint8_t>(VT_OBJECT_TYPE, 0));
  }
  const void *object() const {
    return GetPointer<const void *>(VT_OBJECT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STATUS) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MESSAGE) &&
           verifier.Verify(message()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TRANSACTION) &&
           verifier.Verify(transaction()) &&
           verifier.VerifyVectorOfTables(transaction()) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_OBJECT) &&
           VerifyObject(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
  ResponseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResponseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Response> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(int32_t status) {
    fbb_.AddElement<int32_t>(Response::VT_STATUS, status, 0);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(Response::VT_MESSAGE, message);
  }
  void add_transaction(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transaction>>> transaction) {
    fbb_.AddOffset(Response::VT_TRANSACTION, transaction);
  }
  void add_object_type(Object object_type) {
    fbb_.AddElement<uint8_t>(Response::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0);
  }
  void add_object(flatbuffers::Offset<void> object) {
    fbb_.AddOffset(Response::VT_OBJECT, object);
  }
  ResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResponseBuilder &operator=(const ResponseBuilder &);
  flatbuffers::Offset<Response> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<Response>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response> CreateResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t status = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transaction>>> transaction = 0,
    Object object_type = Object_NONE,
    flatbuffers::Offset<void> object = 0) {
  ResponseBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_transaction(transaction);
  builder_.add_message(message);
  builder_.add_status(status);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Response> CreateResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t status = 0,
    const char *message = nullptr,
    const std::vector<flatbuffers::Offset<Transaction>> *transaction = nullptr,
    Object object_type = Object_NONE,
    flatbuffers::Offset<void> object = 0) {
  return CreateResponse(
      _fbb,
      status,
      message ? _fbb.CreateString(message) : 0,
      transaction ? _fbb.CreateVector<flatbuffers::Offset<Transaction>>(*transaction) : 0,
      object_type,
      object);
}

flatbuffers::Offset<Response> CreateResponse(flatbuffers::FlatBufferBuilder &_fbb, const ResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RequestT : public flatbuffers::NativeTable {
  typedef Request TableType;
  std::vector<std::unique_ptr<TransactionT>> transaction;
  RequestT() {
  }
};

struct Request FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RequestT NativeTableType;
  enum {
    VT_TRANSACTION = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Transaction>> *transaction() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Transaction>> *>(VT_TRANSACTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_TRANSACTION) &&
           verifier.Verify(transaction()) &&
           verifier.VerifyVectorOfTables(transaction()) &&
           verifier.EndTable();
  }
  RequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_transaction(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transaction>>> transaction) {
    fbb_.AddOffset(Request::VT_TRANSACTION, transaction);
  }
  RequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestBuilder &operator=(const RequestBuilder &);
  flatbuffers::Offset<Request> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Request>(end);
    fbb_.Required(o, Request::VT_TRANSACTION);
    return o;
  }
};

inline flatbuffers::Offset<Request> CreateRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transaction>>> transaction = 0) {
  RequestBuilder builder_(_fbb);
  builder_.add_transaction(transaction);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request> CreateRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Transaction>> *transaction = nullptr) {
  return CreateRequest(
      _fbb,
      transaction ? _fbb.CreateVector<flatbuffers::Offset<Transaction>>(*transaction) : 0);
}

flatbuffers::Offset<Request> CreateRequest(flatbuffers::FlatBufferBuilder &_fbb, const RequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QueryT : public flatbuffers::NativeTable {
  typedef Query TableType;
  QueryType type;
  std::string uuid;
  QueryT()
      : type(QueryType_TransactionHistory) {
  }
};

struct Query FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QueryT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_UUID = 6
  };
  QueryType type() const {
    return static_cast<QueryType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::String *uuid() const {
    return GetPointer<const flatbuffers::String *>(VT_UUID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_UUID) &&
           verifier.Verify(uuid()) &&
           verifier.EndTable();
  }
  QueryT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QueryT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Query> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QueryT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QueryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(QueryType type) {
    fbb_.AddElement<int8_t>(Query::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) {
    fbb_.AddOffset(Query::VT_UUID, uuid);
  }
  QueryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QueryBuilder &operator=(const QueryBuilder &);
  flatbuffers::Offset<Query> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Query>(end);
    return o;
  }
};

inline flatbuffers::Offset<Query> CreateQuery(
    flatbuffers::FlatBufferBuilder &_fbb,
    QueryType type = QueryType_TransactionHistory,
    flatbuffers::Offset<flatbuffers::String> uuid = 0) {
  QueryBuilder builder_(_fbb);
  builder_.add_uuid(uuid);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Query> CreateQueryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    QueryType type = QueryType_TransactionHistory,
    const char *uuid = nullptr) {
  return CreateQuery(
      _fbb,
      type,
      uuid ? _fbb.CreateString(uuid) : 0);
}

flatbuffers::Offset<Query> CreateQuery(flatbuffers::FlatBufferBuilder &_fbb, const QueryT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EventSignatureT : public flatbuffers::NativeTable {
  typedef EventSignature TableType;
  std::string publicKey;
  std::string signature;
  EventSignatureT() {
  }
};

struct EventSignature FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EventSignatureT NativeTableType;
  enum {
    VT_PUBLICKEY = 4,
    VT_SIGNATURE = 6
  };
  const flatbuffers::String *publicKey() const {
    return GetPointer<const flatbuffers::String *>(VT_PUBLICKEY);
  }
  const flatbuffers::String *signature() const {
    return GetPointer<const flatbuffers::String *>(VT_SIGNATURE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_PUBLICKEY) &&
           verifier.Verify(publicKey()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_SIGNATURE) &&
           verifier.Verify(signature()) &&
           verifier.EndTable();
  }
  EventSignatureT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EventSignatureT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EventSignature> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EventSignatureT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EventSignatureBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_publicKey(flatbuffers::Offset<flatbuffers::String> publicKey) {
    fbb_.AddOffset(EventSignature::VT_PUBLICKEY, publicKey);
  }
  void add_signature(flatbuffers::Offset<flatbuffers::String> signature) {
    fbb_.AddOffset(EventSignature::VT_SIGNATURE, signature);
  }
  EventSignatureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventSignatureBuilder &operator=(const EventSignatureBuilder &);
  flatbuffers::Offset<EventSignature> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<EventSignature>(end);
    fbb_.Required(o, EventSignature::VT_PUBLICKEY);
    fbb_.Required(o, EventSignature::VT_SIGNATURE);
    return o;
  }
};

inline flatbuffers::Offset<EventSignature> CreateEventSignature(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> publicKey = 0,
    flatbuffers::Offset<flatbuffers::String> signature = 0) {
  EventSignatureBuilder builder_(_fbb);
  builder_.add_signature(signature);
  builder_.add_publicKey(publicKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<EventSignature> CreateEventSignatureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *publicKey = nullptr,
    const char *signature = nullptr) {
  return CreateEventSignature(
      _fbb,
      publicKey ? _fbb.CreateString(publicKey) : 0,
      signature ? _fbb.CreateString(signature) : 0);
}

flatbuffers::Offset<EventSignature> CreateEventSignature(flatbuffers::FlatBufferBuilder &_fbb, const EventSignatureT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConsensusEventT : public flatbuffers::NativeTable {
  typedef ConsensusEvent TableType;
  std::vector<std::unique_ptr<TransactionT>> transaction;
  std::vector<std::unique_ptr<EventSignatureT>> eventSignatures;
  State state;
  ConsensusEventT()
      : state(State_Undetermined) {
  }
};

struct ConsensusEvent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConsensusEventT NativeTableType;
  enum {
    VT_TRANSACTION = 4,
    VT_EVENTSIGNATURES = 6,
    VT_STATE = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<Transaction>> *transaction() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Transaction>> *>(VT_TRANSACTION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<EventSignature>> *eventSignatures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EventSignature>> *>(VT_EVENTSIGNATURES);
  }
  State state() const {
    return static_cast<State>(GetField<int8_t>(VT_STATE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_TRANSACTION) &&
           verifier.Verify(transaction()) &&
           verifier.VerifyVectorOfTables(transaction()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_EVENTSIGNATURES) &&
           verifier.Verify(eventSignatures()) &&
           verifier.VerifyVectorOfTables(eventSignatures()) &&
           VerifyField<int8_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
  ConsensusEventT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConsensusEventT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ConsensusEvent> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConsensusEventT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConsensusEventBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_transaction(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transaction>>> transaction) {
    fbb_.AddOffset(ConsensusEvent::VT_TRANSACTION, transaction);
  }
  void add_eventSignatures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EventSignature>>> eventSignatures) {
    fbb_.AddOffset(ConsensusEvent::VT_EVENTSIGNATURES, eventSignatures);
  }
  void add_state(State state) {
    fbb_.AddElement<int8_t>(ConsensusEvent::VT_STATE, static_cast<int8_t>(state), 0);
  }
  ConsensusEventBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConsensusEventBuilder &operator=(const ConsensusEventBuilder &);
  flatbuffers::Offset<ConsensusEvent> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<ConsensusEvent>(end);
    fbb_.Required(o, ConsensusEvent::VT_TRANSACTION);
    return o;
  }
};

inline flatbuffers::Offset<ConsensusEvent> CreateConsensusEvent(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transaction>>> transaction = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EventSignature>>> eventSignatures = 0,
    State state = State_Undetermined) {
  ConsensusEventBuilder builder_(_fbb);
  builder_.add_eventSignatures(eventSignatures);
  builder_.add_transaction(transaction);
  builder_.add_state(state);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConsensusEvent> CreateConsensusEventDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Transaction>> *transaction = nullptr,
    const std::vector<flatbuffers::Offset<EventSignature>> *eventSignatures = nullptr,
    State state = State_Undetermined) {
  return CreateConsensusEvent(
      _fbb,
      transaction ? _fbb.CreateVector<flatbuffers::Offset<Transaction>>(*transaction) : 0,
      eventSignatures ? _fbb.CreateVector<flatbuffers::Offset<EventSignature>>(*eventSignatures) : 0,
      state);
}

flatbuffers::Offset<ConsensusEvent> CreateConsensusEvent(flatbuffers::FlatBufferBuilder &_fbb, const ConsensusEventT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline BaseObjectT *BaseObject::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BaseObjectT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BaseObject::UnPackTo(BaseObjectT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = text(); if (_e) _o->text = _e->str(); };
  { auto _e = integer(); _o->integer = _e; };
  { auto _e = boolean(); _o->boolean = _e; };
  { auto _e = decimal(); _o->decimal = _e; };
  { auto _e = type(); _o->type = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
}

inline flatbuffers::Offset<BaseObject> BaseObject::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BaseObjectT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBaseObject(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BaseObject> CreateBaseObject(flatbuffers::FlatBufferBuilder &_fbb, const BaseObjectT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _text = _o->text.size() ? _fbb.CreateString(_o->text) : 0;
  auto _integer = _o->integer;
  auto _boolean = _o->boolean;
  auto _decimal = _o->decimal;
  auto _type = _o->type;
  auto _name = _fbb.CreateString(_o->name);
  return CreateBaseObject(
      _fbb,
      _text,
      _integer,
      _boolean,
      _decimal,
      _type,
      _name);
}

inline AssetT *Asset::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AssetT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Asset::UnPackTo(AssetT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = domain(); if (_e) _o->domain = _e->str(); };
  { auto _e = isSingleAsset(); _o->isSingleAsset = _e; };
  { auto _e = objects(); if (_e) for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->objects.push_back(std::unique_ptr<BaseObjectT>(_e->Get(_i)->UnPack(_resolver))); } };
  { auto _e = smartContractName(); if (_e) _o->smartContractName = _e->str(); };
}

inline flatbuffers::Offset<Asset> Asset::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AssetT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAsset(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Asset> CreateAsset(flatbuffers::FlatBufferBuilder &_fbb, const AssetT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  std::cout << "\033[1m\033[92m ---- CreateAsset! -------- \033[0m\n";
  auto _name = _fbb.CreateString(_o->name);
  std::cout << "\033[1m\033[92m ---- CreateAsset! name created -------- \033[0m\n";
  auto _domain = _fbb.CreateString(_o->domain);
  std::cout << "\033[1m\033[92m ---- CreateAsset! domain created -------- \033[0m\n";
  auto _isSingleAsset = _o->isSingleAsset;
  std::cout << "\033[1m\033[92m ---- CreateAsset! isSingle Asset created -------- \033[0m\n";
  auto _objects = _o->objects.size() ? _fbb.CreateVector<flatbuffers::Offset<BaseObject>>(_o->objects.size(), [&](size_t i) { return CreateBaseObject(_fbb, _o->objects[i].get(), _rehasher); }) : 0;
  std::cout << "\033[1m\033[92m ---- CreateAsset! objects created -------- \033[0m\n";
  auto _smartContractName = _o->smartContractName.size() ? _fbb.CreateString(_o->smartContractName) : 0;
  std::cout << "\033[1m\033[92m ---- CreateAsset! smartContract created -------- \033[0m\n";
  return CreateAsset(
      _fbb,
      _name,
      _domain,
      _isSingleAsset,
      _objects,
      _smartContractName);
}

inline AccountT *Account::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AccountT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Account::UnPackTo(AccountT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = publicKey(); if (_e) _o->publicKey = _e->str(); };
  { auto _e = assets(); if (_e) for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->assets.push_back(std::unique_ptr<AssetT>(_e->Get(_i)->UnPack(_resolver))); } };
}

inline flatbuffers::Offset<Account> Account::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AccountT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAccount(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Account> CreateAccount(flatbuffers::FlatBufferBuilder &_fbb, const AccountT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _publicKey = _fbb.CreateString(_o->publicKey);
  auto _assets = _o->assets.size() ? _fbb.CreateVector<flatbuffers::Offset<Asset>>(_o->assets.size(), [&](size_t i) { return CreateAsset(_fbb, _o->assets[i].get(), _rehasher); }) : 0;
  return CreateAccount(
      _fbb,
      _publicKey,
      _assets);
}

inline DomainT *Domain::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DomainT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Domain::UnPackTo(DomainT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ownerPublicKey(); if (_e) _o->ownerPublicKey = _e->str(); };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
}

inline flatbuffers::Offset<Domain> Domain::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DomainT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDomain(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Domain> CreateDomain(flatbuffers::FlatBufferBuilder &_fbb, const DomainT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _ownerPublicKey = _o->ownerPublicKey.size() ? _fbb.CreateString(_o->ownerPublicKey) : 0;
  auto _name = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
  return CreateDomain(
      _fbb,
      _ownerPublicKey,
      _name);
}

inline PeerT *Peer::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PeerT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Peer::UnPackTo(PeerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = publicKey(); if (_e) _o->publicKey = _e->str(); };
  { auto _e = address(); if (_e) _o->address = _e->str(); };
}

inline flatbuffers::Offset<Peer> Peer::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PeerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePeer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Peer> CreatePeer(flatbuffers::FlatBufferBuilder &_fbb, const PeerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _publicKey = _o->publicKey.size() ? _fbb.CreateString(_o->publicKey) : 0;
  auto _address = _o->address.size() ? _fbb.CreateString(_o->address) : 0;
  return CreatePeer(
      _fbb,
      _publicKey,
      _address);
}

inline AddT *Add::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AddT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Add::UnPackTo(AddT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = object_type(); _o->object.type = _e; };
  { auto _e = object(); if (_e) _o->object.table = ObjectUnion::UnPack(_e, object_type(),_resolver); };
}

inline flatbuffers::Offset<Add> Add::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AddT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAdd(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Add> CreateAdd(flatbuffers::FlatBufferBuilder &_fbb, const AddT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _object_type = _o->object.type;
  auto _object = _o->object.Pack(_fbb);
  return CreateAdd(
      _fbb,
      _object_type,
      _object);
}

inline TransferT *Transfer::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TransferT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Transfer::UnPackTo(TransferT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = receiver(); if (_e) _o->receiver = _e->str(); };
  { auto _e = object_type(); _o->object.type = _e; };
  { auto _e = object(); if (_e) _o->object.table = ObjectUnion::UnPack(_e, object_type(),_resolver); };
}

inline flatbuffers::Offset<Transfer> Transfer::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransferT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTransfer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Transfer> CreateTransfer(flatbuffers::FlatBufferBuilder &_fbb, const TransferT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _receiver = _fbb.CreateString(_o->receiver);
  auto _object_type = _o->object.type;
  auto _object = _o->object.Pack(_fbb);
  return CreateTransfer(
      _fbb,
      _receiver,
      _object_type,
      _object);
}

inline UpdateT *Update::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UpdateT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Update::UnPackTo(UpdateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = object_type(); _o->object.type = _e; };
  { auto _e = object(); if (_e) _o->object.table = ObjectUnion::UnPack(_e, object_type(),_resolver); };
}

inline flatbuffers::Offset<Update> Update::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UpdateT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUpdate(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Update> CreateUpdate(flatbuffers::FlatBufferBuilder &_fbb, const UpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _object_type = _o->object.type;
  auto _object = _o->object.Pack(_fbb);
  return CreateUpdate(
      _fbb,
      _object_type,
      _object);
}

inline RemoveT *Remove::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RemoveT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Remove::UnPackTo(RemoveT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = object_type(); _o->object.type = _e; };
  { auto _e = object(); if (_e) _o->object.table = ObjectUnion::UnPack(_e, object_type(),_resolver); };
}

inline flatbuffers::Offset<Remove> Remove::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RemoveT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRemove(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Remove> CreateRemove(flatbuffers::FlatBufferBuilder &_fbb, const RemoveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _object_type = _o->object.type;
  auto _object = _o->object.Pack(_fbb);
  return CreateRemove(
      _fbb,
      _object_type,
      _object);
}

inline BatchT *Batch::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BatchT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Batch::UnPackTo(BatchT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = alias(); if (_e) _o->alias = _e->str(); };
  { auto _e = commands(); if (_e) for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->commands.push_back(_e->Get(_i)->str()); } };
}

inline flatbuffers::Offset<Batch> Batch::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BatchT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBatch(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Batch> CreateBatch(flatbuffers::FlatBufferBuilder &_fbb, const BatchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _alias = _fbb.CreateString(_o->alias);
  auto _commands = _o->commands.size() ? _fbb.CreateVectorOfStrings(_o->commands) : 0;
  return CreateBatch(
      _fbb,
      _alias,
      _commands);
}

inline UnbatchT *Unbatch::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UnbatchT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Unbatch::UnPackTo(UnbatchT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = alias(); if (_e) _o->alias = _e->str(); };
}

inline flatbuffers::Offset<Unbatch> Unbatch::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnbatchT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnbatch(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Unbatch> CreateUnbatch(flatbuffers::FlatBufferBuilder &_fbb, const UnbatchT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _alias = _fbb.CreateString(_o->alias);
  return CreateUnbatch(
      _fbb,
      _alias);
}

inline ContractT *Contract::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ContractT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Contract::UnPackTo(ContractT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = object_type(); _o->object.type = _e; };
  { auto _e = object(); if (_e) _o->object.table = ObjectUnion::UnPack(_e, object_type(),_resolver); };
  { auto _e = command(); if (_e) _o->command = _e->str(); };
  { auto _e = contractName(); if (_e) _o->contractName = _e->str(); };
}

inline flatbuffers::Offset<Contract> Contract::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ContractT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateContract(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Contract> CreateContract(flatbuffers::FlatBufferBuilder &_fbb, const ContractT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _object_type = _o->object.type;
  auto _object = _o->object.Pack(_fbb);
  auto _command = _o->command.size() ? _fbb.CreateString(_o->command) : 0;
  auto _contractName = _fbb.CreateString(_o->contractName);
  return CreateContract(
      _fbb,
      _object_type,
      _object,
      _command,
      _contractName);
}

inline TxSignatureT *TxSignature::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TxSignatureT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TxSignature::UnPackTo(TxSignatureT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = publicKey(); if (_e) _o->publicKey = _e->str(); };
  { auto _e = signature(); if (_e) _o->signature = _e->str(); };
}

inline flatbuffers::Offset<TxSignature> TxSignature::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TxSignatureT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTxSignature(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TxSignature> CreateTxSignature(flatbuffers::FlatBufferBuilder &_fbb, const TxSignatureT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _publicKey = _fbb.CreateString(_o->publicKey);
  auto _signature = _fbb.CreateString(_o->signature);
  return CreateTxSignature(
      _fbb,
      _publicKey,
      _signature);
}

inline TransactionT *Transaction::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TransactionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Transaction::UnPackTo(TransactionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = sender(); if (_e) _o->sender = _e->str(); };
  { auto _e = command_type(); _o->command.type = _e; };
  { auto _e = command(); if (_e) _o->command.table = CommandUnion::UnPack(_e, command_type(),_resolver); };
  { auto _e = txSignatures(); if (_e) for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->txSignatures.push_back(std::unique_ptr<TxSignatureT>(_e->Get(_i)->UnPack(_resolver))); } };
  { auto _e = hash(); if (_e) _o->hash = _e->str(); };
}

inline flatbuffers::Offset<Transaction> Transaction::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TransactionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTransaction(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Transaction> CreateTransaction(flatbuffers::FlatBufferBuilder &_fbb, const TransactionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _sender = _fbb.CreateString(_o->sender);
  auto _command_type = _o->command.type;
  auto _command = _o->command.Pack(_fbb);
  auto _txSignatures = _fbb.CreateVector<flatbuffers::Offset<TxSignature>>(_o->txSignatures.size(), [&](size_t i) { return CreateTxSignature(_fbb, _o->txSignatures[i].get(), _rehasher); });
  auto _hash = _fbb.CreateString(_o->hash);
  return CreateTransaction(
      _fbb,
      _sender,
      _command_type,
      _command,
      _txSignatures,
      _hash);
}

inline ResponseT *Response::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ResponseT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Response::UnPackTo(ResponseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = status(); _o->status = _e; };
  { auto _e = message(); if (_e) _o->message = _e->str(); };
  { auto _e = transaction(); if (_e) for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->transaction.push_back(std::unique_ptr<TransactionT>(_e->Get(_i)->UnPack(_resolver))); } };
  { auto _e = object_type(); _o->object.type = _e; };
  { auto _e = object(); if (_e) _o->object.table = ObjectUnion::UnPack(_e, object_type(),_resolver); };
}

inline flatbuffers::Offset<Response> Response::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResponse(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Response> CreateResponse(flatbuffers::FlatBufferBuilder &_fbb, const ResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _status = _o->status;
  auto _message = _o->message.size() ? _fbb.CreateString(_o->message) : 0;
  auto _transaction = _o->transaction.size() ? _fbb.CreateVector<flatbuffers::Offset<Transaction>>(_o->transaction.size(), [&](size_t i) { return CreateTransaction(_fbb, _o->transaction[i].get(), _rehasher); }) : 0;
  auto _object_type = _o->object.type;
  auto _object = _o->object.Pack(_fbb);
  return CreateResponse(
      _fbb,
      _status,
      _message,
      _transaction,
      _object_type,
      _object);
}

inline RequestT *Request::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RequestT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request::UnPackTo(RequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = transaction(); if (_e) for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->transaction.push_back(std::unique_ptr<TransactionT>(_e->Get(_i)->UnPack(_resolver))); } };
}

inline flatbuffers::Offset<Request> Request::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request> CreateRequest(flatbuffers::FlatBufferBuilder &_fbb, const RequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _transaction = _fbb.CreateVector<flatbuffers::Offset<Transaction>>(_o->transaction.size(), [&](size_t i) { return CreateTransaction(_fbb, _o->transaction[i].get(), _rehasher); });
  return CreateRequest(
      _fbb,
      _transaction);
}

inline QueryT *Query::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new QueryT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Query::UnPackTo(QueryT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = uuid(); if (_e) _o->uuid = _e->str(); };
}

inline flatbuffers::Offset<Query> Query::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QueryT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQuery(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Query> CreateQuery(flatbuffers::FlatBufferBuilder &_fbb, const QueryT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _type = _o->type;
  auto _uuid = _o->uuid.size() ? _fbb.CreateString(_o->uuid) : 0;
  return CreateQuery(
      _fbb,
      _type,
      _uuid);
}

inline EventSignatureT *EventSignature::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EventSignatureT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EventSignature::UnPackTo(EventSignatureT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = publicKey(); if (_e) _o->publicKey = _e->str(); };
  { auto _e = signature(); if (_e) _o->signature = _e->str(); };
}

inline flatbuffers::Offset<EventSignature> EventSignature::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EventSignatureT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEventSignature(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EventSignature> CreateEventSignature(flatbuffers::FlatBufferBuilder &_fbb, const EventSignatureT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _publicKey = _fbb.CreateString(_o->publicKey);
  auto _signature = _fbb.CreateString(_o->signature);
  return CreateEventSignature(
      _fbb,
      _publicKey,
      _signature);
}

inline ConsensusEventT *ConsensusEvent::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ConsensusEventT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ConsensusEvent::UnPackTo(ConsensusEventT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = transaction(); if (_e) for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->transaction.push_back(std::unique_ptr<TransactionT>(_e->Get(_i)->UnPack(_resolver))); } };
  { auto _e = eventSignatures(); if (_e) for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->eventSignatures.push_back(std::unique_ptr<EventSignatureT>(_e->Get(_i)->UnPack(_resolver))); } };
  { auto _e = state(); _o->state = _e; };
}

inline flatbuffers::Offset<ConsensusEvent> ConsensusEvent::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConsensusEventT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConsensusEvent(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ConsensusEvent> CreateConsensusEvent(flatbuffers::FlatBufferBuilder &_fbb, const ConsensusEventT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _transaction = _fbb.CreateVector<flatbuffers::Offset<Transaction>>(_o->transaction.size(), [&](size_t i) { return CreateTransaction(_fbb, _o->transaction[i].get(), _rehasher); });
  auto _eventSignatures = _o->eventSignatures.size() ? _fbb.CreateVector<flatbuffers::Offset<EventSignature>>(_o->eventSignatures.size(), [&](size_t i) { return CreateEventSignature(_fbb, _o->eventSignatures[i].get(), _rehasher); }) : 0;
  auto _state = _o->state;
  return CreateConsensusEvent(
      _fbb,
      _transaction,
      _eventSignatures,
      _state);
}

inline bool VerifyObject(flatbuffers::Verifier &verifier, const void *obj, Object type) {
  switch (type) {
    case Object_NONE: {
      return true;
    }
    case Object_Asset: {
      auto ptr = reinterpret_cast<const Asset *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Object_Domain: {
      auto ptr = reinterpret_cast<const Domain *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Object_Account: {
      auto ptr = reinterpret_cast<const Account *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Object_Peer: {
      auto ptr = reinterpret_cast<const Peer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyObjectVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyObject(
        verifier,  values->Get(i), types->GetEnum<Object>(i))) {
      return false;
    }
  }
  return true;
}

inline flatbuffers::NativeTable *ObjectUnion::UnPack(const void *obj, Object type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case Object_Asset: {
      auto ptr = reinterpret_cast<const Asset *>(obj);
      return ptr->UnPack(resolver);
    }
    case Object_Domain: {
      auto ptr = reinterpret_cast<const Domain *>(obj);
      return ptr->UnPack(resolver);
    }
    case Object_Account: {
      auto ptr = reinterpret_cast<const Account *>(obj);
      return ptr->UnPack(resolver);
    }
    case Object_Peer: {
      auto ptr = reinterpret_cast<const Peer *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ObjectUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case Object_Asset: {
      auto ptr = reinterpret_cast<const AssetT *>(table);
      return CreateAsset(_fbb, ptr, _rehasher).Union();
    }
    case Object_Domain: {
      auto ptr = reinterpret_cast<const DomainT *>(table);
      return CreateDomain(_fbb, ptr, _rehasher).Union();
    }
    case Object_Account: {
      auto ptr = reinterpret_cast<const AccountT *>(table);
      return CreateAccount(_fbb, ptr, _rehasher).Union();
    }
    case Object_Peer: {
      auto ptr = reinterpret_cast<const PeerT *>(table);
      return CreatePeer(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline void ObjectUnion::Reset() {
  switch (type) {
    case Object_Asset: {
      auto ptr = reinterpret_cast<AssetT *>(table);
      delete ptr;
      break;
    }
    case Object_Domain: {
      auto ptr = reinterpret_cast<DomainT *>(table);
      delete ptr;
      break;
    }
    case Object_Account: {
      auto ptr = reinterpret_cast<AccountT *>(table);
      delete ptr;
      break;
    }
    case Object_Peer: {
      auto ptr = reinterpret_cast<PeerT *>(table);
      delete ptr;
      break;
    }
    default: break;
  }
  table = nullptr;
  type = Object_NONE;
}

inline bool VerifyCommand(flatbuffers::Verifier &verifier, const void *obj, Command type) {
  switch (type) {
    case Command_NONE: {
      return true;
    }
    case Command_Add: {
      auto ptr = reinterpret_cast<const Add *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_Transfer: {
      auto ptr = reinterpret_cast<const Transfer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_Update: {
      auto ptr = reinterpret_cast<const Update *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_Remove: {
      auto ptr = reinterpret_cast<const Remove *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_Batch: {
      auto ptr = reinterpret_cast<const Batch *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_Unbatch: {
      auto ptr = reinterpret_cast<const Unbatch *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_Contract: {
      auto ptr = reinterpret_cast<const Contract *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyCommandVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCommand(
        verifier,  values->Get(i), types->GetEnum<Command>(i))) {
      return false;
    }
  }
  return true;
}

inline flatbuffers::NativeTable *CommandUnion::UnPack(const void *obj, Command type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case Command_Add: {
      auto ptr = reinterpret_cast<const Add *>(obj);
      return ptr->UnPack(resolver);
    }
    case Command_Transfer: {
      auto ptr = reinterpret_cast<const Transfer *>(obj);
      return ptr->UnPack(resolver);
    }
    case Command_Update: {
      auto ptr = reinterpret_cast<const Update *>(obj);
      return ptr->UnPack(resolver);
    }
    case Command_Remove: {
      auto ptr = reinterpret_cast<const Remove *>(obj);
      return ptr->UnPack(resolver);
    }
    case Command_Batch: {
      auto ptr = reinterpret_cast<const Batch *>(obj);
      return ptr->UnPack(resolver);
    }
    case Command_Unbatch: {
      auto ptr = reinterpret_cast<const Unbatch *>(obj);
      return ptr->UnPack(resolver);
    }
    case Command_Contract: {
      auto ptr = reinterpret_cast<const Contract *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> CommandUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case Command_Add: {
      auto ptr = reinterpret_cast<const AddT *>(table);
      return CreateAdd(_fbb, ptr, _rehasher).Union();
    }
    case Command_Transfer: {
      auto ptr = reinterpret_cast<const TransferT *>(table);
      return CreateTransfer(_fbb, ptr, _rehasher).Union();
    }
    case Command_Update: {
      auto ptr = reinterpret_cast<const UpdateT *>(table);
      return CreateUpdate(_fbb, ptr, _rehasher).Union();
    }
    case Command_Remove: {
      auto ptr = reinterpret_cast<const RemoveT *>(table);
      return CreateRemove(_fbb, ptr, _rehasher).Union();
    }
    case Command_Batch: {
      auto ptr = reinterpret_cast<const BatchT *>(table);
      return CreateBatch(_fbb, ptr, _rehasher).Union();
    }
    case Command_Unbatch: {
      auto ptr = reinterpret_cast<const UnbatchT *>(table);
      return CreateUnbatch(_fbb, ptr, _rehasher).Union();
    }
    case Command_Contract: {
      auto ptr = reinterpret_cast<const ContractT *>(table);
      return CreateContract(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline void CommandUnion::Reset() {
  switch (type) {
    case Command_Add: {
      auto ptr = reinterpret_cast<AddT *>(table);
      delete ptr;
      break;
    }
    case Command_Transfer: {
      auto ptr = reinterpret_cast<TransferT *>(table);
      delete ptr;
      break;
    }
    case Command_Update: {
      auto ptr = reinterpret_cast<UpdateT *>(table);
      delete ptr;
      break;
    }
    case Command_Remove: {
      auto ptr = reinterpret_cast<RemoveT *>(table);
      delete ptr;
      break;
    }
    case Command_Batch: {
      auto ptr = reinterpret_cast<BatchT *>(table);
      delete ptr;
      break;
    }
    case Command_Unbatch: {
      auto ptr = reinterpret_cast<UnbatchT *>(table);
      delete ptr;
      break;
    }
    case Command_Contract: {
      auto ptr = reinterpret_cast<ContractT *>(table);
      delete ptr;
      break;
    }
    default: break;
  }
  table = nullptr;
  type = Command_NONE;
}

inline const iroha::ConsensusEvent *GetConsensusEvent(const void *buf) {
  return flatbuffers::GetRoot<iroha::ConsensusEvent>(buf);
}

inline const char *ConsensusEventIdentifier() {
  return "IROH";
}

inline bool ConsensusEventBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, ConsensusEventIdentifier());
}

inline bool VerifyConsensusEventBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<iroha::ConsensusEvent>(ConsensusEventIdentifier());
}

inline const char *ConsensusEventExtension() {
  return "iroha";
}

inline void FinishConsensusEventBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<iroha::ConsensusEvent> root) {
  fbb.Finish(root, ConsensusEventIdentifier());
}

inline std::unique_ptr<ConsensusEventT> UnPackConsensusEvent(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ConsensusEventT>(GetConsensusEvent(buf)->UnPack(res));
}

}  // namespace iroha

#endif  // FLATBUFFERS_GENERATED_API_IROHA_H_
